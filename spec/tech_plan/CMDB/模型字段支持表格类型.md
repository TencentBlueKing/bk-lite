# 模型字段支持表格类型 - Tech Plan

日期：2026-03-02

## 技术目标与非目标

### 技术目标
- 在现有 CMDB 架构内新增字段类型 `table`，不引入新服务与新存储。
- 打通模型字段配置、实例录入/更新/详情、列表展示、导入导出全链路。
- 提供可复用、可验证的后端校验与编解码能力，确保导入导出可逆。

### 非目标
- 不支持表格嵌套表格。
- 不支持 `str/number` 之外的子列类型。
- 不实现列级高级规则（必填/唯一/长度/正则）执行，仅保留扩展位。
- 不新增页面，仅扩展现有页面组件。

---

## 1) 文件与目录结构 (File Tree)

> 仅列出本模块涉及的新增/修改文件。`M`=修改，`A`=新增。

```text
server/
└─ apps/cmdb/
   ├─ constants/
   │  └─ constants.py                         (M)
   ├─ services/
   │  └─ model.py                             (M)
   ├─ validators/
   │  └─ field_validator.py                   (M)
   ├─ graph/
   │  └─ falkordb.py                          (M)
   ├─ utils/
   │  ├─ Import.py                            (M)
   │  └─ export.py                            (M)
   └─ model_migrate/
      └─ migrete_service.py                   (M)

web/
└─ src/app/cmdb/
   ├─ constants/
   │  └─ asset.ts                             (M)
   ├─ types/
   │  └─ assetManage.ts                       (M)
   ├─ utils/
   │  └─ common.tsx                           (M)
   └─ (pages)/
      ├─ assetManage/management/detail/attributes/
      │  └─ attributesModal.tsx               (M)
      ├─ assetData/list/
      │  └─ fieldModal.tsx                    (M)
      ├─ assetData/detail/baseInfo/
      │  └─ list.tsx                          (M)
      └─ assetData/
         └─ page.tsx                          (M)

spec/
└─ tech_plan/CMDB/
   └─ 模型字段支持表格类型.md                   (A)
```

---

## 2) 核心数据结构 / Schema 定义

### 2.1 字段 option 结构（模型定义）

```python
from dataclasses import dataclass
from typing import Literal, Any

@dataclass(slots=True)
class TableColumnSpec:
    """table 子列定义"""
    column_id: str            # 必填；同一字段内唯一；标识符格式同 attr_id
    column_name: str          # 必填；用于展示
    column_type: Literal["str", "number"]
    order: int                # >= 1


@dataclass(slots=True)
class TableFieldOption:
    """table 字段 option"""
    columns: list[TableColumnSpec]  # 按 order 升序使用
```

### 2.2 实例值结构（业务态 + 存储态）

```python
from dataclasses import dataclass
from typing import Any

@dataclass(slots=True)
class TableRow:
    """单行数据；key 必须来自 column_id"""
    cells: dict[str, Any]


@dataclass(slots=True)
class TableFieldValue:
    """table 字段值"""
    rows: list[dict[str, Any]]  # 业务态（接口/前端）
    raw: str                    # 存储态：JSON string
```

### 2.3 导入导出单列 JSON 约定

```python
# table 字段独占一列，列名沿用现有字段列命名规则（字段名称/字段 ID）
# 单元格内容存放该字段完整值的 JSON string

def serialize_table_cell(rows: list[dict[str, Any]]) -> str:
  """rows -> JSON string"""
  ...


def deserialize_table_cell(cell: str) -> list[dict[str, Any]]:
  """JSON string -> rows"""
  ...
```

### 2.4 固定口径（本期）
- 子列类型仅 `str`、`number`。
- 单元格空值统一为 `""`。
- 导入回组时“整行全空”直接过滤。
- 实例入库存储为 `JSON string`（读取时再反序列化）。

---

## 3) 核心函数 / 接口签名 (API & Signatures)

> 仅定义签名，不含实现。

### 3.1 后端（Python）

```python
from typing import Any

# option 校验

def validate_table_option(option: list[dict[str, Any]]) -> list[TableColumnSpec]:
    ...

# 值规范化（入库前）
def normalize_table_value_for_store(
    value: str | list[dict[str, Any]],
    option: list[TableColumnSpec],
) -> str:
    """返回 JSON string"""
    ...

# 值解析（出库后）
def parse_table_value_from_store(
    raw: str,
    option: list[TableColumnSpec],
) -> list[dict[str, Any]]:
    ...

# 行级校验

def validate_table_rows(
    rows: list[dict[str, Any]],
    option: list[TableColumnSpec],
) -> None:
    ...

# 导出：展开表头/数据
# 导出：table 字段单列写入

def export_table_attr_to_excel_cell(
  rows: list[dict[str, Any]],
  option: list[TableColumnSpec],
) -> str:
  """返回写入单元格的 JSON string"""
  ...

# 导入：从单元格解析

def parse_table_rows_from_excel_cell(
  cell_value: str,
  attr_id: str,
  option: list[TableColumnSpec],
) -> list[dict[str, Any]]:
    ...

# model_config.xlsx 解析

def parse_model_config_table_option(cell_value: str) -> list[TableColumnSpec]:
    ...
```

### 3.2 前端（TypeScript）

```ts
export type TableColumnType = "str" | "number";

export interface TableColumnSpec {
  column_id: string;
  column_name: string;
  column_type: TableColumnType;
  order: number;
}

export function buildTableColumnDefs(option: TableColumnSpec[]): Array<{
  key: string;
  title: string;
  type: TableColumnType;
}>;

export function serializeTableFieldValue(rows: Array<Record<string, unknown>>): string;

export function deserializeTableFieldValue(raw: string): Array<Record<string, unknown>>;
```

---

## 4) 核心逻辑伪代码 (Step-by-Step Logic)

### 4.1 模型字段新增/编辑（`table`）

```text
1. 接收 attr_info。
2. 若 attr_type != table：走原逻辑。
3. 若 attr_type == table：
   3.1 校验 option 为数组，且每列包含 column_id/column_name/column_type/order。
   3.2 校验 column_id 唯一且格式合法。
   3.3 校验 column_type ∈ {str, number}。
   3.4 按 order 排序并回写 attr.option。
4. 保存模型 attrs。
```

### 4.2 实例创建/更新（校验 + 存储）

```text
1. 遍历待保存字段：
   - 非 table 字段：走现有 FieldValidator 逻辑。
   - table 字段：
     a) 将输入统一为 rows（支持 JSON string / list[dict]）。
     b) 校验 rows 为数组结构；每行键集必须是 column_id 子集。
     c) number 列：非空值必须可转为数值；失败报错（字段+列）。
     d) 空单元格统一转 ""。
     e) rows 序列化为 JSON string 写入 properties[attr_id]。
2. 调用原有 create/update 持久化逻辑。
```

### 4.3 导出（实例 -> Excel）

```text
1. 生成 header 时识别 table 字段。
2. 为 table 字段仅生成 1 列（列名沿用现有字段列规则）。
3. 每条实例：
  - 反序列化 table JSON string -> rows。
  - 执行标准化（空值处理、非法结构兜底策略）。
  - 序列化 rows 为 JSON string 填入该单元格。
```

### 4.4 导入（Excel -> 实例）

```text
1. 读取第三行字段标识。
2. 定位 table 字段对应单列并读取单元格值。
3. 对每个 attr_id：
  - 解析单元格 JSON string 为 rows。
  - 过滤全空行（兼容历史脏值场景）。
   - 执行 number 列类型校验。
   - 序列化为 JSON string 写回 item[attr_id]。
4. 与非 table 字段一起走现有 import save/update。
5. 错误信息返回：行号 + 字段ID +（可选列ID）+ 原因（含 JSON 解析原因）。
```

### 4.5 列表展示（首列2项 + `+N` + hover）

```text
1. 列表单元格渲染时检测 attr_type == table。
2. 反序列化 raw 值，取首列 column_id 对应值。
3. 默认展示前2项胶囊；若总数 > 2 展示 +N。
4. hover +N 时按列顺序渲染完整表格；mouseleave 关闭。
```

---

## 5) 第三方依赖与环境要求 (Dependencies)

- 无新增依赖。
- 复用现有依赖：
  - 后端：Django、openpyxl、pandas（model_init 已在用）
  - 前端：Next.js + Ant Design

---

## 影响范围与改动点

### 后端影响
- 字段类型定义：新增 `table` 类型映射。
- 字段配置校验：模型属性增改时增加 `table option` 校验。
- 实例值校验：复用 `FieldValidator`，增加 `table` 专项分支。
- 导入导出：新增单列 JSON 编解码规则。
- 初始化导入：`model_config.xlsx` 支持 `table` option 解析。

### 前端影响
- 类型枚举与类型定义增加 `table`。
- 字段配置弹窗增加表格列配置。
- 录入/编辑/详情/列表渲染扩展 `table` 类型分支。

### 外部交互边界
- 不改 API 路径。
- 请求/响应字段仍为原 `attr_id` 键值对；`table` 值为 JSON string（与后端存储一致）。

---

## 测试方案

### 单元测试（后端）
- `validate_table_option`：
  - 合法 case（2 列）。
  - 重复 `column_id`。
  - 非法 `column_type`。
- `validate_table_rows`：
  - `number` 列合法/非法。
  - 空值处理。
- `parse_table_rows_from_excel_cell`：
  - 单元格 JSON 解析。
  - 全空行过滤。

### 集成验证（最小链路）
- 模型字段新增 `table` -> 新建实例 -> 详情可读 -> 列表可展示。
- 导出后再导入，结果与原数据一致（往返一致）。
- 非法导入返回可定位错误（行号+字段+列）。

### 回归范围
- 不影响已有字段类型：`str/int/enum/time/user/organization/bool/pwd`。

---

## 发布与回滚策略

### 发布
1. 先上后端（兼容旧字段）。
2. 再上前端（开启 `table` 渲染与编辑）。
3. 小范围灰度验证导入导出链路。

### 回滚
- 前端回滚：回退到上一版构建，`table` 字段仅不可视化编辑，不影响已存数据。
- 后端回滚：回退应用版本；已存 `table` JSON string 保留为普通字符串，不触发结构破坏。
- 导入导出异常时：临时关闭 `table` 字段导入入口，保留查询能力。

---

## 风险与应对

- 风险：历史模型 `option` 脏数据。
  - 应对：读取时加兜底与字段级错误提示。
- 风险：导入单元格 JSON 非法或结构不匹配。
  - 应对：导入前执行 JSON 解析与结构校验，错误信息返回行号+字段ID+原因。
- 风险：`number` 文本污染。
  - 应对：实例创建、更新、导入三处统一校验。
